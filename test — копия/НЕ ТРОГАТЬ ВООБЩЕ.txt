import os
import threading
import time
import random
import ctypes
from ctypes import wintypes
from colorama import init, Fore, Style
import pyfiglet
import pygetwindow as gw
from PIL import ImageGrab
import cv2
import numpy as np
import tkinter as tk
from tkinter import ttk
import pynput

# Инициализация colorama
init(autoreset=True)

# Константы Windows API
VK_6 = 0x36
VK_7 = 0x37
WM_KEYDOWN = 0x0100
WM_KEYUP = 0x0101
MAPVK_VK_TO_VSC = 0

user32 = ctypes.WinDLL('user32', use_last_error=True)
MapVirtualKeyW = user32.MapVirtualKeyW
PostMessageW = user32.PostMessageW

class AutoCP:
    def __init__(self):
        self.running = False
        self.worker_thread = None
        self.check_delay = 0.5
        self.cp_key_1 = VK_6
        self.cp_key_2 = VK_7
        self.window_title = "TyPoRe3 - zMega.com [Mega x10]" # ## Убедитесь, что заголовок окна точный
        self.l2_window = None
        self.status_text = "Бот выключен"
        
        self.cp_threshold_percent = 50  # Порог срабатывания в процентах
        
        # ## ИЗМЕНЕНО: Координаты CP-полосы ОТНОСИТЕЛЬНО окна игры
        # (смещение_X, смещение_Y, ширина, высота)
        self.cp_bar_area = (48, 58, 135, 9) 
        
        # ## ИЗМЕНЕНО: Более точный диапазон для желтого/золотого цвета CP
        self.lower_yellow = np.array([20, 100, 100])
        self.upper_yellow = np.array([35, 255, 255])
        
        self.cp_low_count = 0
        self.required_checks = 2 # Уменьшил для более быстрой реакции

        # --- Переменные для GUI ---
        self.root = None
        self.label = None
        self.progressbar = None
        self.cp_percent_value = 0

    def print_status_to_console(self):
        os.system('cls' if os.name == 'nt' else 'clear')
        title = pyfiglet.figlet_format("Auto CP Bot", font="slant")
        print(f"{Fore.CYAN}{title}{Style.RESET_ALL}")
        print(f"{Fore.GREEN}Нажмите F1 для старта, F2 для остановки, F4 для выхода.")
        print(f"{Fore.YELLOW}Статус: {self.status_text}")
        print(f"{Fore.MAGENTA}Окно игры: {'Найдено' if self.l2_window else 'Не найдено'}")
        print("-" * 40)

    def find_window(self):
        try:
            windows = gw.getWindowsWithTitle(self.window_title)
            if windows:
                self.l2_window = windows[0]
                return True
            else:
                self.l2_window = None
                return False
        except Exception:
            self.l2_window = None
            return False

    # ## ИЗМЕНЕНО: Упрощенная и более надежная функция
    def get_cp_percentage(self, frame):
        """
        Вычисляет процент заполненности CP-полосы.
        """
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        
        # Создаем маску для желтого цвета
        mask = cv2.inRange(hsv, self.lower_yellow, self.upper_yellow)
        
        # Считаем количество желтых пикселей
        yellow_pixels = cv2.countNonZero(mask)
        
        # Общее количество пикселей в изображении полосы
        total_pixels = frame.shape[0] * frame.shape[1]
        
        if total_pixels == 0:
            return 0
            
        # Возвращаем процент
        return (yellow_pixels / total_pixels) * 100

    def send_key_to_window(self, key_code):
        if not self.l2_window or not self.l2_window.isActive: 
            self.status_text = "Окно игры неактивно!"
            return
        try:
            hwnd = self.l2_window._hWnd
            scan_code = MapVirtualKeyW(key_code, MAPVK_VK_TO_VSC)
            l_param_down = (scan_code << 16) | 1
            l_param_up = (scan_code << 16) | 0xC0000001
            
            PostMessageW(hwnd, WM_KEYDOWN, key_code, l_param_down)
            time.sleep(random.uniform(0.05, 0.08))
            PostMessageW(hwnd, WM_KEYUP, key_code, l_param_up)
        except Exception as e:
            self.status_text = f"Ошибка отправки: {e}"

    def perform_cp_action(self):
        print(f"{Fore.RED}CP низкий! Использую банки...")
        self.send_key_to_window(self.cp_key_1)
        time.sleep(random.uniform(0.1, 0.2))
        self.send_key_to_window(self.cp_key_2)

    def auto_cp_loop(self):
        self.status_text = f"Бот запущен. Порог: {self.cp_threshold_percent}%"
        self.print_status_to_console()
        
        while self.running:
            if not self.find_window():
                self.status_text = f"Окно '{self.window_title}' потеряно..."
                self.print_status_to_console()
                time.sleep(2)
                continue

            try:
                # ## ИЗМЕНЕНО: Вычисляем абсолютные координаты для скриншота
                win_left, win_top = self.l2_window.topleft
                x, y, w, h = self.cp_bar_area
                bbox = (win_left + x, win_top + y, win_left + x + w, win_top + y + h)

                screenshot = ImageGrab.grab(bbox=bbox)
                frame = cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)
                
                # Сохраняем изображение для отладки (можно закомментировать)
                cv2.imwrite("cp_bar_capture.png", frame)
                
                self.cp_percent_value = self.get_cp_percentage(frame)
                
                self.status_text = f"CP: {self.cp_percent_value:.1f}%"
                
                if self.cp_percent_value < self.cp_threshold_percent:
                    self.cp_low_count += 1
                    if self.cp_low_count >= self.required_checks:
                        self.perform_cp_action()
                        self.cp_low_count = 0
                        time.sleep(1) # Небольшая задержка после использования банок
                else:
                    self.cp_low_count = 0

            except Exception as e:
                self.status_text = f"Ошибка в цикле: {e}"
                # Не останавливаем бота при мелких ошибках
            
            self.print_status_to_console()
            time.sleep(self.check_delay)

    def start_worker(self):
        if self.running: return
        
        if not self.find_window():
            self.status_text = f"Окно '{self.window_title}' не найдено."
            self.print_status_to_console()
            return
            
        self.running = True
        self.worker_thread = threading.Thread(target=self.auto_cp_loop, daemon=True)
        self.worker_thread.start()

    def stop_worker(self):
        if self.running:
            self.running = False
            if self.worker_thread and self.worker_thread.is_alive():
                self.worker_thread.join(timeout=1)
            self.status_text = "Бот остановлен"
            self.cp_percent_value = 0
            self.print_status_to_console()

    # --- Функции для GUI (оверлей) ---
    def create_overlay(self):
        self.root = tk.Tk()
        self.root.overrideredirect(True)
        self.root.attributes("-topmost", True)
        self.root.attributes("-alpha", 0.8)
        self.root.geometry("280x60-10+10") # Расположение в правом верхнем углу
        self.root.config(bg="black")
        
        self.label = tk.Label(self.root, text=self.status_text, font=("Arial", 10), fg="white", bg="black")
        self.label.pack(pady=5)
        
        style = ttk.Style()
        style.theme_use('clam')
        # Стиль для прогресс-бара
        style.configure("yellow.Horizontal.TProgressbar", troughcolor='gray20', background='gold')
        
        self.progressbar = ttk.Progressbar(self.root, orient="horizontal", length=250, mode="determinate", style="yellow.Horizontal.TProgressbar")
        self.progressbar.pack(pady=2)

        self.update_overlay()
        
    def update_overlay(self):
        self.label.config(text=self.status_text)
        self.progressbar['value'] = self.cp_percent_value
        # Рекурсивный вызов для постоянного обновления
        self.root.after(200, self.update_overlay)

    # --- Управление через горячие клавиши ---
    def on_press(self, key):
        if key == pynput.keyboard.Key.f1:
            self.start_worker()
        elif key == pynput.keyboard.Key.f2:
            self.stop_worker()
        elif key == pynput.keyboard.Key.f4:
            print(f"{Fore.RED}[!] Выход из программы...")
            self.running = False
            if self.root:
                self.root.destroy()
            os._exit(0)

    def run(self):
        self.print_status_to_console()
        listener = pynput.keyboard.Listener(on_press=self.on_press)
        listener.daemon = True
        listener.start()
        
        self.create_overlay()
        self.root.mainloop()

if __name__ == "__main__":
    autocp = AutoCP()
    autocp.run()